## Mathematical derivation

### Determination of the period of the rational number M/N:  

- Finite decimals: continually divide the remainder until the remainder is 0. The period is 1, since thereafter it is 0 repeated over and over again  
- Infinite cyclic decimals: keep dividing the remainder until there is no more new remainder. Since the remainder will only take values in (1, N), it will always start repeating. The period is then determined by $i_{second-occurrence} - i _ {first-occurrence}$.  
### About Base
Easier to understand from decimal numbers: it only decide what should you time with after you get the remainder. Eg. 1/7 base on 10: first remainder is 1, to proceed to next digit, we time it with 10 and get the next remainder, and go on. When it comes to other cases like base=4, we just time the remainder with 4. The position of the digit determines the power it should be multiplied by base.
### Finding fractional expressions for rational numbers
Given a rational number $\frac MN$ with prefix $(a_1,a_2, ... ,a_m)$ and period $(b_1,b_2,...,b_n)$ expanded on base $k$ , we can find the fractional expression by following steps:

$$0.a_1a_2...a_m \dot{b_1}b_2b_3... \dot{b_n} \times k^m=a_1a_2...a_m . \dot{b_1}b_2b_3... \dot{b_n}$$
$$0.a_1a_2...a_m \dot{b_1}b_2b_3... \dot{b_n} \times k^{m+n}=a_1a_2...a_mb_1b_2b_3...b_n . \dot{b_1}b_2b_3... \dot{b_n}$$
$$\frac MN=\frac{a_1a_2...a_mb_1b_2b_3...b_n . \dot{b_1}b_2b_3... \dot{b_n}-a_1a_2...a_m . \dot{b_1}b_2b_3... \dot{b_n}}{k^{m+n}-k^{m}}$$
The nominator can be simplified as $a_1a_2...a_m \times (k^n-1)+b_1b_2b_3...b_n$
The denominator can be simplified as $k^m \times (k^n-1)$
As it might not be the lowest form, we might also need to deduct by gcd for both nominator and denominator to get the value of $M$ and $N$.
## Function building
The essential of dividing is divide -> multiply remainder by the base -> divide again. we can achieve that simply by loop. 
From the previous part we know the loop length determined by remainders' reoccurrence interval. We need to keep track on the remainders. 
In function `period_counter()` we do it by creating a list of reminders we get in every step.  So the Boolean expression in the control statement should be whether the current remainder already exist in the remainder list. If there is, the period is found.
Two type of cases need to take into consideration:
1. Infinite cyclic decimals:
	While division proceed, we match the current remainder with existing elements in the remainder list. Once we get a replicate, we can determine the period by the index of the first occurrence and second occurrence of this remainder.
2. Finite decimals
	If we get a remainder is 0, that means the rational number of interest is a finite decimal. As defined in the material, the period of finite decimals is 1.
In function `nstep_sequence()` we're simply repeating the same loop with `period_counter()`, but this time we have step limit and the required output is the expanded sequence. So instead of tracking remainders, we store the quotient we get each step, and The control flow should evaluate whether the required number of loops have been executed.
For function `reduction()`, we first convert sequence to integer, multiply each digit by the power of base and add up together. Instead of loop by the index which might produce memory error when dealing with long sequences, we used `enumerate()` and `reversed()`. They are memory-efficient because they don't create an additional copy of the original sequence. They provide a view of the sequence that can be iterated through. After reverse, The power of base each digit should multiplied by is exactly the index, hence we can calculate each of them within one line of code: 
```python
prefix_value = sum(d * base**i for i, d in enumerate(reversed(prefix)))
period_value = sum(d * base**i for i, d in enumerate(reversed(period)))
```
To take care of long sequence I also considered using `numpy`. Convert sequence into an np.array and a power array generated by `np.power()` . To calculate the value of prefix or period you only need to multiply sequence array by the power array and get the sum of it. It's relatively faster than iterating by index but still have overflow if the input sequence is long enough. `enumerate()` and `reversed()` is the best way I could find.
Last but not the least, to make sure the output is in lowest form (mutually prime), divide both nominator and denominator by their greatest common divisor.
## About the X walk
The rational number that generate periodic regular X walk is:

$$
\frac{3187590611734673093733862189195428029331123358985841104}{4903985730770844346746710486880989387579965190987526963}
$$

To find this number, first write down the sequence for the walk. I manually simulated how to get a path as such and write down the corresponding sequence. Then I use the `reduction()` function to calculate nominator and denominator. I want it to be a periodic regular walk so I make the walk end at the same spot it started, and set prefix an empty tuple.